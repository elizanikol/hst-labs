# HST-Cuda

## Бизнес логика:
Сформировать M результирующих векторов как квадрат максимального значения по каждой строке M исходных квадратных матриц.

## Вариант исполнения:
Реализация через Cuda.

## Особенности исполнения:
Считывание данных происходит из бинарного файла;
Данные генерируются утилитой, принимающей в качестве параметров размер данных для обработки в мегабайтах и имя файла;
Программа выполняет бизнес-логику и записывает результат в выходной файл;
В конце файла с результатами сохраняется информация о времени выполнения вычислений и размере обработанных данных.

## Описание алгоритма выполнения бизнес-логики:
1. Для генерации исходных данных используется функция ```GenerateMatricesAndSaveThemToFile()```. 
С помощью ```std::default_random_engine``` определяется количество строк очередной квадратной матрицы, которая затем заполняется произвольными значениями типа double в диапазоне [0, 10] и записывается в бинарный файл ```InputDataFile```. 
Генерация матриц заканчивается после того, как размер файла с данными превысит размер, введенный пользователем.

2. После этого запускается программа-клиент, считывающая сгенерированные матрицы из ```InputDataFile```. В функции ```CalculateMaxElementsSquare()``` над исходными данными выполняются вычисления: для каждой строки i-ой матрицы вычисляется максимальное значение, которое возводится в квадрат и записывается в результирующий i-ый вектор.
3. Определяется время выполнения вычислений, которое записывается в бинарный файл ```ResultsFile``` вместе с результатами вычислений.

## Описание логики распараллеливания:
Вычисления квадратов максимальных значений выполняются в функции ```MaxElement```, для этого в память устройства загружаются сразу все исходные данные в ```deviceData``` и смещения строк каждой матрицы в массиве ```deviceOffsets```. Результаты вычислений записываются в массив ```deviceResults```. 
Распараллеливание осуществляется путем задания нужного числа нитей ```blockSize``` для одновременного выполнения вычислений (максимальное 1024 для видеокарты "Tesla K20Xm"), с последующим вычислением ```gridSize``` как ```(resultsSize + NumThreads - 1) / NumThreads```. Каждая нить вычисляет максимальный элемент одной строки матрицы, таким образом, общее число нитей равно суммарному количеству строк всех матриц в исходных данных.
![Снимок экрана 2022-11-20 164219](https://user-images.githubusercontent.com/55412039/202905463-5bea0a30-343e-4710-97a5-44f95a530f1a.png)

Передача данных между хостом и устройством осуществляется с помощью функций ```cudaMemcpy(..., cudaMemcpyHostToDevice)``` и ```cudaMemcpy(..., cudaMemcpyDeviceToHost)```.
Для определения времени вычислений используются cudaEventRecord(), cudaEventCreate(), cudaEventSynchronize(), cudaEventElapsedTime().

## График зависимости времени вычислений от размера исходных данных:
Результаты для cuda приведены при ```blockSize=1024```.
![Снимок экрана 2022-11-20 011635](https://user-images.githubusercontent.com/55412039/202905660-5f483511-9334-45db-92d8-67c76b2884e3.png)

